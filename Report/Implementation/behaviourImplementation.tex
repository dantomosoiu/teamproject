\documentclass{article}
\usepackage{algorithm2e}
\begin{document}
\section{Implementing the Peceive, Decide, Act process}
Here we discuss the techniques and algorithms used to realise the Perceive, Decide, Act process previously discussed [Reference to Research].

%%%%%%%%%%%%%%%%%%%%%%%%%Perception Implementation
\subsection{Perception}
Agent perception is achieved using the following simple algorithm:

\begin{algorithm}[H] %%%%%%%Agent Perception Algorithms
 \SetAlgoLined
 \SetKwInOut{Input}{input}
 \SetKwInOut{Output}{output}
 \Input{The set of goals in the environment: \emph{goals}}
 \Output{A set of goals visible to the user at the given instant in time: \emph{visibleGoals}}
 \BlankLine
 \For{each goal g in goals}{
  \If{g is in line of sight of agent}{
    add g to visibleGoals\;
  }
  }
  \caption{Agent Perception Algorithm}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%Decision Implementation
\subsection{Decision Making}
In the Research Chapter [Reference] the three classes of human behaviour considered in the scope of this project were defined. In practice, only herding behaviour implemented as part of the Decide step; queueing and competetive behaviour must be handled asynchronously using collision avoidance techniques [Reference to Dan's work].\\
To decide on a new action, an agent must select one of the visible goals that were found in the Perceive step (if any). Otherwise it must continue on its current path. The decision making process is realised using an extendable algorithm, which sequentially considers sets of different classes of goal according to their priority. Exits have the highest priority.\\

The final algorithm only makes decisions regarding exits, for reasons we will discuss later in the report. However it is easy to extend this process to include other goal types by adding further conditionals following the pattern laid out below.\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%Decide Algorithm
\begin{algorithm}[H]
 \SetAlgoLined
 \SetKwInOut{Input}{input}
 \SetKwInOut{Output}{output}
 \Input{Person person, ExitGoal[ ] exits /*add further exit types here as arrays */}
 \Output{Target Goal for agent to move toward}
 \eIf{no of exits $>$ 0}{
   ExitGoal \emph{currentExit} = $exits[0]$\;
   \eIf{person is stressed}{
     \For{each exit \emph{e} in exits}{
       \If{number of people queuing at e $>$ no. of people queueing at targetExit}{
	targetExit = e\;
	}
      }
    return targetExit\;
    }{ %%%%%%%%%%%inner else
     Vector3f position = person.location\;
     \For{each exit e in exits}{
       \If{distance to e $<$ distance to targetExit}{
	targetExit = e\;
	}
      }
      return targetExit\;
     }
}{ %%%%%%%%outer else
  return null;
}
\end{algorithm}

\subsection{Act}
This step's representation in the BehaviouralModel class is trivial since the Decide step already returns a target goal. It is left in as a place for performing any calculations which should be performed before returning the target goal to the agent.\\
Upon receiving a new target goal, an agent should perform the following:
\begin{itemize}
\item{Use a PersonNavmeshRoutePlanner to calculate a route to this goal}
\item{Set the returned MotionPath as the current MotionPath for the agent}
\item{Begin moving down this path}
\end{itemize}




\end{document}
     
     
 

    

